library(simglm)
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 1 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
dists <- vector() # vetor para armazenar as distancias
dists[1] <- 0 # distancia inicial 0
hyp_betas <- betas # vetor inicial para distribuir os efeitos
hypothesis <- list() # vetor para armazenar as hipoteses
# hipotese inicial
hypothesis[[1]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', betas)
for (i in 2:500) {
hyp_betas[1] <- hyp_betas[1] - 0.01
hyp_betas[c(2,3,4)] <- hyp_betas[c(2,3,4)] + 0.1/3
hypothesis[[i]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', hyp_betas)
dists[[i]] <- dist(rbind(betas, hyp_betas), method = "euclidean")
}
dists
p_test <- matrix(nrow = length(hypothesis),
ncol = length(models))
for (i in 1:length(models)) {
for (j in 1:length(hypothesis)) {
p_test[j,i] <- mc_linear_hypothesis(object =  models[[i]],
hypothesis = hypothesis[[j]])$P_valor
}
}
# converte resultado para dataframe
p_test <- as.data.frame(p_test)
# acrescenta info de distancia
p_test$dist <- dists
p_test
plot(p_test$V1, p_test$dist)
p_test$V1
p_test$dist
plot(p_test$V1~p_test$dist)
plot(p_test$V1~p_test$dist, 'l')
?plot(p_test$V1~p_test$dist, 'l')
plot(p_test$V1~p_test$dist, type = 'l')
p_test$V1
plot(p_test$V10~p_test$dist, type = 'l')
plot(p_test$V30~p_test$dist, type = 'l')
plot(p_test$V40~p_test$dist, type = 'l')
lines(p_test$V30~p_test$dist)
lines(p_test$dist, p_test[,3])
lines(p_test$dist, p_test[,3], col =2)
plot(p_test$dist, p_test[,1], col =2)
plot(p_test$dist, p_test[,1],type = 'l', col =2)
1:nrow(p_test)
plot(p_test$dist, p_test[,1],type = 'l', col =2)
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col =2)
}
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(1,3))
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(0,3))
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(0,2))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col =2)
}
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(0,3))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col =2)
}
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(0,5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col =2)
}
plot(p_test$dist, p_test[,1],type = 'l', col =2,
xlim = c(0,5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
#----------------------------------------------------------------
library(mcglm)
library(Matrix)
library(tidyverse)
library(simglm)
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 1 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
dists <- vector() # vetor para armazenar as distancias
dists[1] <- 0 # distancia inicial 0
hyp_betas <- betas # vetor inicial para distribuir os efeitos
hypothesis <- list() # vetor para armazenar as hipoteses
# hipotese inicial
hypothesis[[1]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', betas)
for (i in 2:500) {
hyp_betas[1] <- hyp_betas[1] - 0.01
hyp_betas[c(2,3,4)] <- hyp_betas[c(2,3,4)] + 0.1/3
hypothesis[[i]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', hyp_betas)
dists[[i]] <- dist(rbind(betas, hyp_betas), method = "euclidean")
}
hypothesis
dists
hypothesis[[19]]
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
dists
#----------------------------------------------------------------
hypothesis[[36]]
#----------------------------------------------------------------
dists[36]
hypothesis[[36]]
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,2))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,1.5))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,2))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,10))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,20))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3))
#----------------------------------------------------------------
library(mcglm)
library(Matrix)
library(tidyverse)
library(simglm)
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 1 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
dists <- vector() # vetor para armazenar as distancias
dists[1] <- 0 # distancia inicial 0
hyp_betas <- betas # vetor inicial para distribuir os efeitos
hypothesis <- list() # vetor para armazenar as hipoteses
# hipotese inicial
hypothesis[[1]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', betas)
for (i in 2:500) {
hyp_betas[1] <- hyp_betas[1] - 0.01
hyp_betas[c(2,3,4)] <- hyp_betas[c(2,3,4)] + 0.1/3
hypothesis[[i]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', hyp_betas)
dists[[i]] <- dist(rbind(betas, hyp_betas), method = "euclidean")
}
p_test <- matrix(nrow = length(hypothesis),
ncol = length(models))
for (i in 1:length(models)) {
for (j in 1:length(hypothesis)) {
p_test[j,i] <- mc_linear_hypothesis(object =  models[[i]],
hypothesis = hypothesis[[j]])$P_valor
}
}
# converte resultado para dataframe
p_test <- as.data.frame(p_test)
# acrescenta info de distancia
p_test$dist <- dists
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
dists
#----------------------------------------------------------------
dists[27]
hypothesis[[27]]
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
#----------------------------------------------------------------
dists[27]
hypothesis[[27]]
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,2))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,1.8))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,2))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3),
xlim = c(0,1))
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3),
ylim = c(0,1))
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3),
ylim = c(0,1),
xlab = 'dist',
ylab = 'p-valor')
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 5 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
datasets
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 3 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 2 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
sample_size = 100 # tamanho das amostras
n_datasets = 50 # numero de conjuntos de dados
variance_error = 1.5 # variabilidade da amostra simulada
betas <- c(5,0,0,0) # valores dos parametros de regressao
sim_arguments <- list(
formula = y ~ x,
fixed = list(x = list(var_type = 'factor',
levels = c('A', 'B', 'C', 'D'))),
error = list(variance = variance_error),
sample_size = sample_size,
reg_weights = betas
)
datasets <- list()
for (i in 1:n_datasets) {
dados <- simulate_fixed(data = NULL, sim_arguments) %>%
simulate_error(sim_arguments) %>%
generate_response(sim_arguments)
datasets[[i]] <- dados[c('x','y')]
}
form <- y ~ x # preditor
Z0 <- mc_id(datasets[[1]]) # matriz identidade para o preditor matricial
models <- list()
for (i in 1:n_datasets) {
fit <-
mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
link = c("identity"),
variance = c("tweedie"),
data = datasets[[i]])
models[[i]] <- fit
print(i)
}
dists <- vector() # vetor para armazenar as distancias
dists[1] <- 0 # distancia inicial 0
hyp_betas <- betas # vetor inicial para distribuir os efeitos
hypothesis <- list() # vetor para armazenar as hipoteses
# hipotese inicial
hypothesis[[1]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', betas)
for (i in 2:500) {
hyp_betas[1] <- hyp_betas[1] - 0.01
hyp_betas[c(2,3,4)] <- hyp_betas[c(2,3,4)] + 0.1/3
hypothesis[[i]] <- paste(c('beta10',
'beta11',
'beta12',
'beta13'), '=', hyp_betas)
dists[[i]] <- dist(rbind(betas, hyp_betas), method = "euclidean")
}
p_test <- matrix(nrow = length(hypothesis),
ncol = length(models))
for (i in 1:length(models)) {
for (j in 1:length(hypothesis)) {
p_test[j,i] <- mc_linear_hypothesis(object =  models[[i]],
hypothesis = hypothesis[[j]])$P_valor
}
}
# converte resultado para dataframe
p_test <- as.data.frame(p_test)
# acrescenta info de distancia
p_test$dist <- dists
plot(p_test$dist, p_test[,1],type = 'l', col = 1,
xlim = c(0,3),
ylim = c(0,1),
xlab = 'dist',
ylab = 'p-valor')
for (i in 1:ncol(p_test)) {
lines(p_test$dist, p_test[,i], col = i)
}
