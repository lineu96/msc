library(Matrix)
y <- rnorm(100,10,3)
q <- quantile(y, probs = c(((100/3)/100), (((100/3)*2)/100)))
x <- ifelse(y<=q[1], 'a', NA)
x <- ifelse(y>q[1] & y<= q[2], 'b', x)
x <- ifelse(y>q[2], 'c', x)
df <- data.frame(y = y,
x = x)
plot(y~x, df)
# Preditor
form  <- y ~ x
# GLM
m1 <- glm(formula = form, data = df)
m1
Z0 <- mc_id(df) # Identidade
m2 <- mcglm(linear_pred = c(form),
matrix_pred = list(c(Z0)),
data = df)
# Estimativas
data.frame(glm = round(m1$coefficients, 2),
mcglm = round(m2$Regression, 2))
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
library(car)
## Tipo III
Anova(m1, type = 'III', test.statistic = 'Wald')
mc_anova_III(m2)[[1]]
mc_manova_III(m2)
m1
## Testando se todos os parametros sao 0
linearHypothesis(m1, c("(Intercept) = 0",
"xb = 0",
"xc = 0"))
## Testando se todos os parametros sao 0
?linearHypothesis(m1, c("(Intercept) = 0",
"xb = 0",
"xc = 0"))
## Testando se todos os parametros sao 0
teste<-linearHypothesis(m1, c("(Intercept) = 0",
"xb = 0",
"xc = 0"))
teste
linearHypothesis(m1,
hypothesis.matrix = c(0,-1,0),
rhs = 0)
library(multcomp)
summary(glht(m1, mcp(rank="Tukey")))
m1
library(emmeans)
marginal = emmeans(m1, ~ x)
marginal
marginal[[1]]
class(marginal)
marginal
pairs(marginal)
?emmeans(m1, ~ x)
linearHypothesis(m1,
hypothesis.matrix = c(0,-1,0),
rhs = 0)
pairs(marginal)
#' rownames(X) <- letters[nrow(X):1]
#' apc(X)
#'
#' apc(X, lev = LETTERS[1:nrow(X)])
#'
#' # Objects from doBy::LSmatrix() have an "grid" attribute.
#' attr(X, "grid") <- data.frame(n = LETTERS[1:nrow(X)])
#' rownames(X) <- NULL
#' apc(X)
#'
apc <- function(lfm, lev = NULL) {
rn <- rownames(lfm)
a <- attr(lfm, "grid")
if (is.null(lev)) {
if (!is.null(a)) {
lev <- apply(a, 1, paste, collapse = ":")
} else if (!is.null(rn)) {
lev <- rn
} else {
lev <- as.character(1:nlev)
}
}
cbn <- utils::combn(seq_along(lev), 2)
M <- lfm[cbn[1, ], ] - lfm[cbn[2, ], ]
if (is.vector(M)) {
dim(M) <- c(1, length(M))
}
rownames(M) <- paste(lev[cbn[1, ]], lev[cbn[2, ]], sep = "-")
return(M)
}
lat_R.lm <- lm(y ~ x, data = df)
lat_R.lm
lsm <- LSmeans(lat_R.lm, effect = c("x"))
??LSmeans
library(doBy)
lat_R.lm <- lm(y ~ x, data = df)
lsm <- LSmeans(lat_R.lm, effect = c("x"))
lsm
lsm$L
lsm$grid$x
by(lsm$L, INDICES = lsm$grid$x, FUN = as.matrix)
lapply(L, apc)
L <- by(lsm$L, INDICES = lsm$grid$x, FUN = as.matrix)
lapply(L, apc)
L <- by(lsm$L, INDICES = lsm$grid$x, FUN = as.matrix)
L
library(doBy)
lat_R.lm <- lm(y ~ x, data = df)
lsm <- LSmeans(lat_R.lm, effect = c("x"))
L <- by(lsm$L, INDICES = lsm$grid$x, FUN = as.matrix)
L
lsm
lsm$L
library(multcomp)
?multcomp::contrMat()
n <- c(10,20,30,40)
n
names(n) <- paste("group", 1:4, sep="")
n
contrMat(n)	# Dunnett is default
contrMat(n, base = 2)	# use second level as baseline
contrMat(n, type = "Tukey")
names(n) <- c('a','b','c')
n
n <- c(10,20,30)
names(n) <- c('a','b','c')
n
contrMat(n)	# Dunnett is default
contrMat(n)	# Dunnett is default
contrMat(n)	# Dunnett is default
contrMat(n, base = 2)	# use second level as baseline
contrMat(n, type = "Tukey")
contrMat(n, type = "Sequen")
contrMat(n, type = "AVE")
contrMat(n, type = "Changepoint")
contrMat(n, type = "Williams")
contrMat(n, type = "Marcus")
contrMat(n, type = "McDermott")
### Umbrella-protected Williams contrasts, i.e. a sequence of
### Williams-type contrasts with groups of higher order
### stepwise omitted
contrMat(n, type = "UmbrellaWilliams")
### comparison of each group with grand mean of all groups
contrMat(n, type = "GrandMean")
contrMat(n, type = "Tukey")
n <- c(10,20,30)
names(n) <- c('b','c','a')
contrMat(n, type = "Tukey")
n <- c(NA,NA,NA)
names(n) <- c('a','b','c')
contrMat(n, type = "Tukey")
n <- c(0,0,0)
names(n) <- c('a','b','c')
contrMat(n, type = "Tukey")
L <- contrMat(n, type = "Tukey")
by(L, INDICES = names(n), FUN = as.matrix)
m1
glht(m1, linfct = mcp(x = "Tukey"))
t<-glht(m1, linfct = mcp(x = "Tukey"))
t$rhs
t$linfct
L
library(multcomp)
?multcomp::contrMat()
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- contrMat(n, type = "Tukey")
L <- by(L, INDICES = names(n), FUN = as.matrix)
L
t<-glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
t$linfct*-1
?TukeyHSD
summary(fm1 <- aov(y ~ x, data = df))
TukeyHSD(fm1, "x", ordered = TRUE)
t<-TukeyHSD(fm1, "x", ordered = TRUE)
t$x
?TukeyHSD
TukeyHSD(fm1, "x", ordered = TRUE)
L
t$linfct
t<-glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
?glht
library(multcomp)
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- contrMat(n, type = "Tukey")
L
t<-glht(m1, linfct = mcp(x = "Tukey"))
t$linfct*-1
t$linfct
L <- ??contrMat(n, type = "Tukey")
?contrMat
contrMat(n, type = "Tukey")
?glht
t<-glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
library(emmeans)
str(warpbreaks)
lattice::xyplot(breaks ~ tension | wool,
data = warpbreaks,
type = c("p", "a"))
m0 <- glm(breaks ~ tension * wool,
data = warpbreaks,
family = quasipoisson)
summary(m0)
anova(m0, test = "F")
emm <- emmeans(m0, spec = ~tension | wool)
str(emm)
summary(emm)
class(emm)
methods(class = "emmGrid")
contrast(emm)
as.glht(emm)
pairs(emm)
unlist(emm)
str(emm)
isS4(emm)
slotNames(emm)
emm@grid
emm@linfct
# Estimativa pontual das médias.
emm@linfct %*% coef(m0)
# Erro padrão das médias.
sqrt(diag(emm@linfct %*% vcov(m0) %*% t(emm@linfct)))
# Para construção de matrizes.
emm@grid
# Criando a matriz com as médias marginais.
# Aqui é a média de cada combinação tension:wool.
L <- ref_grid(m0,
at = list(tension = levels(warpbreaks$tension),
wool = levels(warpbreaks$wool)))
L@linfct
L <- ref_grid(m0)
L@linfct
# Criando a matriz com as médias marginais.
# Aqui são para as médias marginais de tension
L <- ref_grid(m0,
at = list(tension = "H"))
L@linfct
# Médias marginais.
emm <- emmeans(m0, spec = ~tension)
str(emm)
# Médias marginais.
emm <- emmeans(m0, spec = ~tension)
str(emm)
emm@grid
emm@linfct
library(doBy)
# Médias marginais de "tension".
LE_matrix(m0, effect = "tension")
# Médias para combinações
LE_matrix(m0, effect = c("tension", "wool"))
# Médias para tension fixando wool.
LE_matrix(m0, effect = c("tension"), at = list(wool = "A"))
m0 <- glm(y ~ x,
data = df)
summary(m0)
anova(m0, test = "F")
emm <- emmeans(m0, spec = ~x)
str(emm)
summary(emm)
class(emm)
methods(class = "emmGrid")
contrast(emm)
as.glht(emm)
pairs(emm)
unlist(emm)
str(emm)
isS4(emm)
slotNames(emm)
emm@grid
emm@linfct
# Estimativa pontual das médias.
emm@linfct %*% coef(m0)
# Erro padrão das médias.
sqrt(diag(emm@linfct %*% vcov(m0) %*% t(emm@linfct)))
# Para construção de matrizes.
emm@grid
# Criando a matriz com as médias marginais.
# Aqui é a média de cada combinação tension:wool.
L <- ref_grid(m0,
at = list(tension = levels(warpbreaks$tension),
wool = levels(warpbreaks$wool)))
L
L@linfct
L <- ref_grid(m0)
L
L@linfct
library(emmeans)
m0 <- glm(y ~ x,
data = df)
library(mcglm)
library(Matrix)
library(car)
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
y <- rnorm(100,10,3)
q <- quantile(y, probs = c(((100/3)/100), (((100/3)*2)/100)))
x <- ifelse(y<=q[1], 'a', NA)
x <- ifelse(y>q[1] & y<= q[2], 'b', x)
x <- ifelse(y>q[2], 'c', x)
df <- data.frame(y = y,
x = x)
plot(y~x, df)
library(emmeans)
m0 <- glm(y ~ x,
data = df)
summary(m0)
anova(m0, test = "F")
emm <- emmeans(m0, spec = ~x)
str(emm)
summary(emm)
class(emm)
methods(class = "emmGrid")
contrast(emm)
as.glht(emm)
pairs(emm)
unlist(emm)
str(emm)
isS4(emm)
slotNames(emm)
emm@grid
emm@linfct
# Estimativa pontual das médias.
emm@linfct %*% coef(m0)
# Erro padrão das médias.
sqrt(diag(emm@linfct %*% vcov(m0) %*% t(emm@linfct)))
# Para construção de matrizes.
emm@grid
# Criando a matriz com as médias marginais.
# Aqui é a média de cada combinação tension:wool.
L <- ref_grid(m0,
at = list(x = levels(x)))
levels(x)
# Criando a matriz com as médias marginais.
# Aqui é a média de cada combinação tension:wool.
L <- ref_grid(m0,
at = list(x = levels(df$x)))
L
L@linfct
L <- ref_grid(m0)
L
L@linfct
library(doBy)
# Médias marginais de "tension".
LE_matrix(m0, effect = "x")
library(emmeans)
str(warpbreaks)
m0 <- glm(breaks ~ tension * wool,
data = warpbreaks,
family = quasipoisson)
summary(m0)
anova(m0, test = "F")
emm <- emmeans(m0, spec = ~tension | wool)
str(emm)
summary(emm)
class(emm)
methods(class = "emmGrid")
contrast(emm)
as.glht(emm)
pairs(emm)
unlist(emm)
str(emm)
isS4(emm)
slotNames(emm)
emm@grid
emm@linfct
# Estimativa pontual das médias.
emm@linfct %*% coef(m0)
# Erro padrão das médias.
sqrt(diag(emm@linfct %*% vcov(m0) %*% t(emm@linfct)))
# Para construção de matrizes.
emm@grid
# Criando a matriz com as médias marginais.
# Aqui é a média de cada combinação tension:wool.
L <- ref_grid(m0,
at = list(tension = levels(warpbreaks$tension),
wool = levels(warpbreaks$wool)))
L@linfct
L <- ref_grid(m0)
L@linfct
# wagner
F_AB = ( 0 −1 0 )
F_AC = ( 0 0 −1 )
F_BC = ( 0 1 −1 )
#contrMat
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- multcomp::contrMat(n, type = "Tukey")
L
L <- by(L, INDICES = names(n), FUN = as.matrix)
L
L
#glht
t <- glht(m1, linfct = mcp(x = "Tukey"))
#glht
t <- multcomp::glht(m1, linfct = mcp(x = "Tukey"))
library(mcglm)
library(Matrix)
library(car)
source('~/msc/3_th_mcglm/0_funcoes/functions.R')
y <- rnorm(100,10,3)
q <- quantile(y, probs = c(((100/3)/100), (((100/3)*2)/100)))
x <- ifelse(y<=q[1], 'a', NA)
x <- ifelse(y>q[1] & y<= q[2], 'b', x)
x <- ifelse(y>q[2], 'c', x)
df <- data.frame(y = y,
x = x)
plot(y~x, df)
# Preditor
form  <- y ~ x
# GLM
m1 <- glm(formula = form, data = df)
#glht
t <- multcomp::glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
L
#contrMat
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- multcomp::contrMat(n, type = "Tukey")
L <- by(L, INDICES = names(n), FUN = as.matrix)
L
#contrMat
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- multcomp::contrMat(n, type = "Tukey")
L
t <- multcomp::glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
L
t$linfct
#doby
doBy::LE_matrix(m1, effect = "tension")
#doby
doBy::LE_matrix(m1, effect = "x")
L
t
L
t$linfct
#doby
doBy::LE_matrix(m1, effect = "x")
#contrMat
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- multcomp::contrMat(n, type = "Tukey")
L <- by(L, INDICES = names(n), FUN = as.matrix)
L <- multcomp::contrMat(n, type = "Tukey")
L
#glht
t <- multcomp::glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
matrix(nrow = 3,ncol = 3,
data = c(0, −1,  0,
0,  0, -1,
0,  1, -1)
)
c(0, −1,  0,
0,  0, -1,
0,  1, -1)
matrix(nrow = 3,ncol = 3,
data = c(0, -1,  0,
0,  0, -1,
0,  1, -1))
matrix(nrow = 3,ncol = 3,
data = c(0, -1,  0,
0,  0, -1,
0,  1, -1),
byrow = T)
#------------------------------------------------------------
# wagner
# F_AB = ( 0 −1 0 )
# F_AC = ( 0 0 −1 )
# F_BC = ( 0 1 −1 )
matrix(nrow = 3,ncol = 3,
data = c(0, -1,  0,
0,  0, -1,
0,  1, -1),
byrow = T)
#Isso assume que o contraste é o treatment.
#------------------------------------------------------------
#contrMat
n <- c(0,0,0)
names(n) <- c('a','b','c')
L <- multcomp::contrMat(n, type = "Tukey")
L <- by(L, INDICES = names(n), FUN = as.matrix)
L
# Isso assume que não há nível de referência,
# ou seja, o beta já são as médias marginais.
#No anterior, o beta são os betas mesmo,
#conforme seja a parametrização/esquema
#de codificação.
#------------------------------------------------------------
#glht
t <- multcomp::glht(m1, linfct = mcp(x = "Tukey"))
t$linfct
# Isso ela retorna quando usa-se constrastes tipo
# treatment. Se você usar contrastes soma zero, então
# essa matriz muda.
#------------------------------------------------------------
#doby
doBy::LE_matrix(m1, effect = "x")
#------------------------------------------------------------
matrix(nrow = 3,ncol = 3,
data = c(0, -1,  0,
0,  0, -1,
0,  1, -1),
byrow = T)
multcomp::contrMat(n, type = "Tukey")
t$linfct
#doby
doBy::LE_matrix(m1, effect = "x")
