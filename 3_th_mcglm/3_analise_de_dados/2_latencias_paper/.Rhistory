theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p237') + ylab('') + ggtitle('n')
o <- ggplot(data = dados2,
mapping = aes_string(x='p4', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p4') + ylab('') + ggtitle('o')
p <- ggplot(data = dados2,
mapping = aes_string(x='p1', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p1') + ylab('') + ggtitle('p')
x11()
ggpubr::ggarrange(a,b,c,d,e,f,g,h,
i,j,k,l,m,n,o,p,
nrow = 2, ncol = 8)
#---------------------------------------------------------------
library(mcglm)
setwd("~/msc/3_th_mcglm/3_analise_de_dados/2_latencias_paper")
dados <- read.csv2('~/msc/3_th_mcglm/3_analise_de_dados/2_latencias_paper/latencias_1_NOVA.csv',  header = T,  sep = ',')
#---------------------------------------------------------------
# DADOS
#---------------------------------------------------------------
# Diretório dos dados e biblioteca
library(mcglm)
library(Matrix)
library(tidyverse)
#---------------------------------------------------------------
# Leitura e tratamento dos dados
dados <- read.csv2('~/msc/3_th_mcglm/3_analise_de_dados/2_latencias_paper/latencias_1_NOVA.csv',  header = T,  sep = ',')
names(dados) <- c('n',  'code',  'inst',  'op0',  'op1',  'op2',
'lock',  'set_rex',  'segment',  'mem_xchg',
'p0156',  'p06',  'p23',  'p237',  'p4',  'p1',
'p15',  'p015',  'p5',  'p0',  'p05',  'p01',
'p6',  'min_lat',  'max_lat',  'count')
## Seleção das variaveis de interesse
dados <- select(dados,  n,  inst,  lock,  segment,
p0156,  p06,  p23, p237,  p4,  p1,  p15,  p0,  p05,
min_lat,  max_lat,  count)
## Transformando portas em binária
dados$lock <- as.factor(ifelse(dados$lock > 0,  1, 0))
dados$p0156 <- as.factor(ifelse(dados$p0156 > 0,  1, 0))
dados$p06 <- as.factor(ifelse(dados$p06 > 0,  1, 0))
dados$p23 <- as.factor(ifelse(dados$p23 > 0,  1, 0))
dados$p0 <- as.factor(ifelse(dados$p0 > 0,  1, 0))
dados$p237 <- as.factor(ifelse(dados$p237 > 0,  1, 0))
dados$p4 <- as.factor(ifelse(dados$p4 > 0,  1, 0))
dados$p1 <- as.factor(ifelse(dados$p1 > 0,  1, 0))
dados$p15 <- as.factor(ifelse(dados$p15 > 0,  1, 0))
dados$segment <- ifelse(dados$segment > 0,  1, 0)
## Selecionando instruções
exclusao <-c('CMPXCHG8B',
'CMPXCHG8B_LOCK',
'DIV_NOREX',
'DIV_REX',
'ENTER',
'ENTER_W',
'IDIV_NOREX',
'IDIV_REX',
'MOVSB',
'MOVSD',
'MOVSW',
'SGDT',
'SIDT',
'SLDT',
'STOSB',
'STOSD',
'STOSW',
'MOV_DR',
'VERR',
'BTC_LOCK',
'BTR_LOCK',
'BTS_LOCK',
'LAR',
'LSL',
'VERW',
'XCHG_NOREX',
'XCHG_REX',
'POP',
'DIV',
'IDIV',
'PUSH',
'XCHG',
'BTC',
'BTR',
'BTS',
'MOV',
'RCL',
'RCR'
)
#barplot(table(dados$max_lat))
dados2 <- subset(dados, !(dados$inst %in% exclusao))
nrow(dados)-nrow(dados2)
#---------------------------------------------------------------
# EXPLORATÓRIA
#---------------------------------------------------------------
a <- ggplot(dados2, aes(x = min_lat)) +
geom_histogram(col = 1, fill='white') +
xlab('Count') +
ylab('Frequency') +
theme_bw() +
#scale_y_continuous(breaks = round(seq(0, 120, length.out = 3), 2)) +
ggtitle('a')
b <- ggplot(data = dados2,
mapping = aes_string(x='lock', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('Lock') + ylab('Min. Lat.') + ggtitle('b')
c <- ggplot(data = dados2,
mapping = aes_string(x='p0156', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p0156') + ylab('') + ggtitle('c')
d <- ggplot(data = dados2,
mapping = aes_string(x='p06', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p06') + ylab('') + ggtitle('d')
e <- ggplot(data = dados2,
mapping = aes_string(x='p23', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p23') + ylab('') + ggtitle('e')
f <- ggplot(data = dados2,
mapping = aes_string(x='p237', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p237') + ylab('') + ggtitle('f')
g <- ggplot(data = dados2,
mapping = aes_string(x='p4', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p4') + ylab('') + ggtitle('g')
h <- ggplot(data = dados2,
mapping = aes_string(x='p1', y='min_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p1') + ylab('') + ggtitle('h')
i <- ggplot(dados2, aes(x = max_lat)) +
geom_histogram(col = 1, fill='white') +
xlab('Count') +
ylab('Frequency') +
theme_bw() +
#scale_y_continuous(breaks = round(seq(0, 120, length.out = 3), 2)) +
ggtitle('i')
j <- ggplot(data = dados2,
mapping = aes_string(x='lock', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('Lock') + ylab('Max. Lat.') + ggtitle('j')
k <- ggplot(data = dados2,
mapping = aes_string(x='p0156', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p0156') + ylab('') + ggtitle('k')
l <- ggplot(data = dados2,
mapping = aes_string(x='p06', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p06') + ylab('') + ggtitle('l')
m <- ggplot(data = dados2,
mapping = aes_string(x='p23', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p23') + ylab('') + ggtitle('m')
n <- ggplot(data = dados2,
mapping = aes_string(x='p237', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p237') + ylab('') + ggtitle('n')
o <- ggplot(data = dados2,
mapping = aes_string(x='p4', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p4') + ylab('') + ggtitle('o')
p <- ggplot(data = dados2,
mapping = aes_string(x='p1', y='max_lat')) +
stat_boxplot(geom ='errorbar')+
geom_boxplot(alpha = 1)+
theme_light() +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=3,
color="red",
fill="red")+
xlab('p1') + ylab('') + ggtitle('p')
x11()
ggpubr::ggarrange(a,b,c,d,e,f,g,h,
i,j,k,l,m,n,o,p,
nrow = 2, ncol = 8)
#---------------------------------------------------------------
x11()
ggpubr::ggarrange(a,b,c,d,e,f,g,h,
i,j,k,l,m,n,o,p,
nrow = 2, ncol = 8)
form.min_lat <- min_lat ~ (lock + p0156 + p06 + p23 + p237 + p4 + p1 #+ p15 + p0
)
form.max_lat <- max_lat ~ (lock + p0156 + p06 + p23 + p237 + p4 + p1 #+ p15 + p0
)
Z0 <- mc_id(dados2) # Identidade
fit <-
mcglm(linear_pred = c(form.min_lat,
form.max_lat),
matrix_pred = list(c(Z0),
c(Z0)),
link = c("log", "log"),
variance = c("poisson_tweedie", "poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.5,
max_iter = 6000,
tol = 1e-8),
power_fixed = c(F,F),
data = dados2)
matplot(fit$IterationCovariance, type = 'l', xlim = c(1,65))
summary(fit)
coef(fit, type = 'beta')
coef(fit, type = 'tau')
coef(fit, type = 'power')
## chol(vcov) inversa
chol_inv <- Matrix::chol(fit$inv_C)
## Resíduos empilhados
residuos <- as.numeric(residuals(fit, type = 'raw'))
## Produto matricial
pearson <- as.numeric(chol_inv%*%residuos)
## Preditos
preditos <- fit$fitted
## Dataframe
res_pred <- data.frame(index = rep(1:nrow(dados2),2),
resp = c(rep('min_lat', nrow(dados2)),
rep('max_lat', nrow(dados2))),
observado = c(dados2$min_lat,
dados2$max_lat),
preditos = preditos,
pearson = pearson,
raw = residuos
)
mean1 = MASS::fitdistr(res_pred$pearson[1:nrow(dados2)],
densfun = "normal")$estimate[1]
sd1 = MASS::fitdistr(res_pred$pearson[1:nrow(dados2)],
densfun = "normal")$estimate[2]
mean2 = MASS::fitdistr(res_pred$pearson[(nrow(dados2)+1):nrow(res_pred)],
densfun = "normal")$estimate[1]
sd2 = MASS::fitdistr(res_pred$pearson[(nrow(dados2)+1):nrow(res_pred)],
densfun = "normal")$estimate[2]
mean1
sd1
mean2
sd2
mean3 = MASS::fitdistr(res_pred$raw[1:nrow(dados2)],
densfun = "normal")$estimate[1]
sd3 = MASS::fitdistr(res_pred$raw[1:nrow(dados2)],
densfun = "normal")$estimate[2]
mean4 = MASS::fitdistr(res_pred$raw[(nrow(dados2)+1):nrow(res_pred)],
densfun = "normal")$estimate[1]
sd4 = MASS::fitdistr(res_pred$raw[(nrow(dados2)+1):nrow(res_pred)],
densfun = "normal")$estimate[2]
mean3
sd3
mean4
sd4
g1 <- ggplot(data = res_pred, aes(x=pearson))+
geom_histogram(fill=1,alpha=0.5, col = 1)+
theme_bw()+
xlab('')+
ylab('')+
geom_vline(xintercept = 0, col = 2, lty = 2, lwd = 1)+
facet_wrap(~resp, scales = 'free') +
ggtitle('Resíduo Pearson')
g2 <- ggplot(data = res_pred, aes(x=raw))+
geom_histogram(fill=1,alpha=0.5, col = 1)+
theme_bw()+
xlab('')+
ylab('')+
geom_vline(xintercept = 0, col = 2, lty = 2, lwd = 1)+
facet_wrap(~resp, scales = 'free') +
ggtitle('Resíduo cru')
ggpubr::ggarrange(g1,g2, nrow = 2)
g1 <- ggplot(data = res_pred,
mapping = aes(sample = pearson)) +
geom_qq(alpha = 0.5) + geom_qq_line(col = 2)+
theme_bw() +
xlab('')+
ylab('Quantis amostrais') +
ggtitle('Resíduo Pearson') + facet_wrap(~resp, scales = 'free')
g2 <- ggplot(data = res_pred,
mapping = aes(sample = raw)) +
geom_qq(alpha = 0.5) + geom_qq_line(col = 2)+
theme_bw() +
xlab('Quantis teóricos')+
ylab('Quantis amostrais') +
ggtitle('Resíduo cru') + facet_wrap(~resp, scales = 'free')
ggpubr::ggarrange(g1,g2, nrow = 2)
g1 <- ggplot(data = res_pred, aes(y=pearson,x=preditos))+
geom_point(alpha=0.5)+
theme_bw()+
geom_smooth(col=2, method = 'loess', se=F)+
xlab('')+
ylab('Resíduos') +
ggtitle('Resíduo Pearson') + facet_wrap(~resp, scales = 'free')
g2 <- ggplot(data = res_pred, aes(y=raw,x=preditos))+
geom_point(alpha=0.5)+
theme_bw()+
geom_smooth(col=2, method = 'loess', se=F)+
xlab('Preditos')+
ylab('Resíduos') +
ggtitle('Resíduo cru') + facet_wrap(~resp, scales = 'free')
ggpubr::ggarrange(g1,g2, nrow = 2)
dados2$pred_min <- res_pred$preditos[1:nrow(dados2)]
dados2$pred_max <- res_pred$preditos[(nrow(dados2)+1):nrow(res_pred)]
dados2$pearson_min <- res_pred$pearson[1:nrow(dados2)]
dados2$pearson_max <- res_pred$pearson[(nrow(dados2)+1):nrow(res_pred)]
dados2$raw_min <- res_pred$raw[1:nrow(dados2)]
dados2$raw_max <- res_pred$raw[(nrow(dados2)+1):nrow(res_pred)]
mal_ajustados <- subset(dados2,
pearson_min   >  3    |
pearson_min < -3    |
pearson_max  >  3 |
pearson_max  < -3 #|
#pred_min > 25|
#pred_max > 15
)
nrow(mal_ajustados)
massa <- subset(dados2,  !(dados2$n %in% mal_ajustados$n))
analista <- subset(dados2,(dados2$n %in% mal_ajustados$n))
nrow(dados2)
nrow(massa) + nrow(analista)
# SAIDA DO MODELO
resumo <- summary(fit)
betas_min <- round(resumo[[1]]$Regression, 4)
betas_max <- round(resumo[[2]]$Regression, 4)
round(resumo$`Resp.Variable 1`$Power,4)
round(resumo$`Resp.Variable 1`$tau,4)
round(resumo$`Resp.Variable 2`$Power,4)
round(resumo$`Resp.Variable 2`$tau,4)
confint(fit)
beta_min <- data.frame(name = rownames(resumo$`Resp.Variable 1`$Regression),
exp_est = exp(round(resumo$`Resp.Variable 1`$Regression$Estimates,2)),
ic_min = as.vector(exp(confint(fit)[1:8,])[,1]),
ic_max = as.vector(exp(confint(fit)[1:8,])[,2]))
beta_max <- data.frame(name = rownames(resumo$`Resp.Variable 2`$Regression),
exp_est = exp(round(resumo$`Resp.Variable 2`$Regression$Estimates,2)),
ic_min = as.vector(exp(confint(fit)[9:16,])[,1]),
ic_max = as.vector(exp(confint(fit)[9:16,])[,2]))
beta_min[,2:4] <- round(beta_min[,2:4],2)
beta_max[,2:4] <- round(beta_max[,2:4],2)
beta_min
beta_max
##p41
paste0('A media da latencia minima quando é usada a porta ', beta_min$name[7],
' é ', beta_min$exp_est[7], ' vezes a media de quando ela não é usada, mantendo fixos os valores das demais variáveis. Com 95% de confiança o intervalo entre ',
beta_min$ic_min[7], ' e ', beta_min$ic_max[7], ' realmente contém o parâmetro.')
predito <- function(lock, p0156, p06,
p23, p237, p4,
p1){
betas <- data.frame(beta_name = c('intercept',
'lock', 'p0156',
'p06', 'p23',
'p237', 'p4', 'p1'),
estim_min = coef(fit, type = 'beta')$Estimates[1:8],
estim_max = coef(fit, type = 'beta')$Estimates[9:16])
min <- exp(
betas$estim_min[1] +           #intercept
betas$estim_min[2]  *  lock  + #lock
betas$estim_min[3]  *  p0156 + #p0156
betas$estim_min[4]  *  p06   + #p06
betas$estim_min[5]  *  p23   + #p23
betas$estim_min[6]  *  p237  + #p237
betas$estim_min[7]  *  p4    + #p4
betas$estim_min[8]  *  p1      #p1
)
max <- exp(
betas$estim_max[1] +            #intercept
betas$estim_max[2]  *  lock  +  #lock
betas$estim_max[3]  *  p0156 +  #p0156
betas$estim_max[4]  *  p06   +  #p06
betas$estim_max[5]  *  p23   +  #p23
betas$estim_max[6]  *  p237  +  #p237
betas$estim_max[7]  *  p4    +  #p4
betas$estim_max[8]  *  p1       #p1
)
out <- data.frame(min_lat = min,
max_lat = max)
return(out)
}
dados2[sample(nrow(dados2),1),c('lock',
'p0156',
'p06',
'p23',
'p237',
'p4',
'p1',
'min_lat',
'max_lat')]
predito(lock  =  0,
p0156 =  0,
p06   =  0,
p23   =  0,
p237  =  0,
p4    =  0,
p1    =  0)
