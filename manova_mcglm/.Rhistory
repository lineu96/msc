F_all <- diag(length(p_var))
F_all
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
F_par
# Matriz G
G <- diag(n_resp)
G
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
L_par
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(fit_jointP$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
tabela
mc_manova(fit_jointP)
#----------------------------------------------------------------
library(mcglm)
dados <- read.csv2("dados_ovelhas.csv",
header = T,
sep = ";",
dec = ',')
dados2 <- dados[,c(1,2,3,4,
14,15,17,21,
7,9,10,11)]
dados2$momento <- ordered(dados2$tempo,
levels=c("Antes", "Durante", "Depois"))
form.ncorpo <- ncorpo ~ sessao + tempo + linhagem
form.ncorpo2 <- ncorpo ~ sessao + tempo + linhagem
form.ncorpo3 <- ncorpo ~ sessao + tempo + linhagem
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
summary(fit_jointP)
# Vetor beta chapeu
#beta <- coef(fit_jointP, type = "beta")[,1]
beta <- coef(fit_jointP, type = "beta")[,c(1, 4)]
# Número de betas
#n_beta <- length(beta)
n_beta <- sum(as.vector(table(beta$Response)))
beta
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
n_beta
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
n_resp
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(fit_jointP)[1:n_beta, 1:n_beta]
vcov_betas
dim(vcov_betas)
attr(fit_jointP$list_X[[1]], "assign")
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
# Índice que associa beta a variável
p_var <- attr(fit_jointP$list_X[[1]], "assign")
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
F_all
F_all
p_var
# Matriz G
G <- diag(n_resp)
G
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
# Matriz G
G <- diag(n_resp)
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
L_par
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(fit_jointP$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
tabela
mc_manova(fit_jointP)
form.ncorpo <- ncorpo ~ sessao + tempo + linhagem
form.ncorpo2 <- ncabeca ~ sessao + tempo + linhagem
form.ncorpo3 <- norelha ~ sessao + tempo + linhagem
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
summary(fit_jointP)
# Vetor beta chapeu
beta <- coef(fit_jointP, type = "beta")[,c(1, 4)]
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(fit_jointP)[1:n_beta, 1:n_beta]
# Índice que associa beta a variável
p_var <- attr(fit_jointP$list_X[[1]], "assign")
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
# Matriz G
G <- diag(n_resp)
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(fit_jointP$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
tabela
mc_manova(fit_jointP)
anova(fit_jointP)
#################################################################
# ANOVA VIA TESTE WALD
mc_anova <- function(object){
# Vetor beta chapeu e indice de resposta
beta <- coef(object, type = "beta")[,c(1, 4)]
#----------------------------------------------------------------
# Número de betas por resposta
n_beta <- as.vector(table(beta$Response))
#----------------------------------------------------------------
# Número de respostas
n_resp <- length(n_beta)
#----------------------------------------------------------------
# Lista vcov por resposta desconsiderando parametros de dispersao e potencia
vcov_betas <- list()
vcov_betas[[1]] <- vcov(object)[1:n_beta[1], 1:n_beta[1]]
for (i in 2:n_resp) {
vcov_betas[[i]] <-
vcov(object)[(cumsum(n_beta)[i-1]+1):(cumsum(n_beta)[i]),
(cumsum(n_beta)[i-1]+1):(cumsum(n_beta)[i])]
}
#----------------------------------------------------------------
# Índice que associa beta a variável por resposta
p_var <- list()
for (i in 1:n_resp) {
p_var[[i]] <- attr(object$list_X[[i]], "assign")
}
#----------------------------------------------------------------
# Matriz L para todos os parâmetros (Hypothesis matrix), por resposta
L_all <- list()
for (i in 1:n_resp) {
L_all[[i]] <- diag(length(p_var[[i]]))
}
#----------------------------------------------------------------
# Matriz L por variável (Hypothesis matrix), por resposta
L_par <- list()
for (i in 1:n_resp) {
L_par[[i]] <- by(data = L_all[[i]],
INDICES = p_var[[i]],
FUN = as.matrix)
}
#----------------------------------------------------------------
## Tabela
tabela <- list()
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (j in 1:n_resp) {
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(beta, beta$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_betas[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(beta, beta$Response == j)$Estimates))
gl[i] <- nrow(L_par[[j]][[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = c("Intercept",
attr(terms(object$linear_pred[[j]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
return(tabela)
}
mc_manova <- function(object){
#----------------------------------------------------------------
# Vetor beta chapeu
beta <- coef(object, type = "beta")[,c(1, 4)]
#----------------------------------------------------------------
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
#----------------------------------------------------------------
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
#----------------------------------------------------------------
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(object)[1:n_beta, 1:n_beta]
#----------------------------------------------------------------
# Índice que associa beta a variável
p_var <- attr(object$list_X[[1]], "assign")
#----------------------------------------------------------------
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
#----------------------------------------------------------------
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
#----------------------------------------------------------------
# Matriz G
G <- diag(n_resp)
#----------------------------------------------------------------
# Matriz L
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
#----------------------------------------------------------------
## Tabela
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
### Estatística de teste:
#### t(L*beta) x (L*vcov*t(L))^-1 x (L*beta) ~ Qui-quadrado(numero de parametros testados)
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(object$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
#----------------------------------------------------------------
return(tabela)
}
mc_manova(fit_jointP)
mcglm::mc_manova(fit_jointP)
fit_jointP$Regression
coef(fit_jointP, type = "beta")[,c(1, 4)]
?mcglm::mc_manova
?mcglm::mc_manova
#----------------------------------------------------------------
library(mcglm)
dados <- read.csv2("dados_ovelhas.csv",
header = T,
sep = ";",
dec = ',')
dados2 <- dados[,c(1,2,3,4,
14,15,17,21,
7,9,10,11)]
dados2$momento <- ordered(dados2$tempo,
levels=c("Antes", "Durante", "Depois"))
form.ncorpo <- ncorpo ~ sessao + tempo + linhagem
form.ncorpo2 <- ncabeca ~ sessao + tempo + linhagem
form.ncorpo3 <- norelha ~ sessao + tempo
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
summary(fit_jointP)
# Vetor beta chapeu
beta <- coef(fit_jointP, type = "beta")[,c(1, 4)]
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(fit_jointP)[1:n_beta, 1:n_beta]
# Índice que associa beta a variável
p_var <- attr(fit_jointP$list_X[[1]], "assign")
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
# Matriz G
G <- diag(n_resp)
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(fit_jointP$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
tabela
mc_manova(fit_jointP)
#----------------------------------------------------------------
library(mcglm)
dados <- read.csv2("dados_ovelhas.csv",
header = T,
sep = ";",
dec = ',')
dados2 <- dados[,c(1,2,3,4,
14,15,17,21,
7,9,10,11)]
dados2$momento <- ordered(dados2$tempo,
levels=c("Antes", "Durante", "Depois"))
form.ncorpo <- ncorpo ~ sessao
form.ncorpo2 <- ncabeca ~ sessao
form.ncorpo3 <- norelha ~ sessao
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
summary(fit_jointP)
# Vetor beta chapeu
beta <- coef(fit_jointP, type = "beta")[,c(1, 4)]
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(fit_jointP)[1:n_beta, 1:n_beta]
# Índice que associa beta a variável
p_var <- attr(fit_jointP$list_X[[1]], "assign")
# Matriz F para todos os parâmetros (Hypothesis matrix)
F_all <- diag(length(p_var))
# Matriz F por variável (Hypothesis matrix)
F_par <- by(data = F_all,
INDICES = p_var,
FUN = as.matrix)
# Matriz G
G <- diag(n_resp)
L_par <- list()
for (i in 1:length(F_par)) {
L_par[[i]] <- kronecker(G, F_par[[i]])
}
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:length(L_par)) {
W[i] <- as.numeric((t(L_par[[i]]%*%beta$Estimates)) %*% (solve(L_par[[i]]%*%vcov_betas%*%t(L_par[[i]]))) %*% (L_par[[i]]%*%beta$Estimates))
gl[i] <- nrow(L_par[[i]])
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela <- data.frame(Variável = c("Intercept",
attr(terms(fit_jointP$linear_pred[[1]]), "term.labels")),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
tabela
mc_manova(fit_jointP)
#----------------------------------------------------------------
library(mcglm)
dados <- read.csv2("dados_ovelhas.csv",
header = T,
sep = ";",
dec = ',')
dados2 <- dados[,c(1,2,3,4,
14,15,17,21,
7,9,10,11)]
dados2$momento <- ordered(dados2$tempo,
levels=c("Antes", "Durante", "Depois"))
form.ncorpo <- ncorpo ~ sessao
form.ncorpo <- ncorpo ~ (sessao+momento+linhagem)^2
form.ncorpo2 <- ncabeca ~ (sessao+momento+linhagem)^2
form.ncorpo3 <- norelha ~ (sessao+momento+linhagem)^2
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
summary(fit_jointP)
summary(fit_jointP)
# Vetor beta chapeu
beta <- coef(fit_jointP, type = "beta")[,c(1, 4)]
beta
# Número de betas
n_beta <- sum(as.vector(table(beta$Response)))
n_beta
# Número de respostas
n_resp <- length(as.vector(table(beta$Response)))
n_resp
# vcov desconsiderando parametros de dispersao e potencia
vcov_betas <- vcov(fit_jointP)[1:n_beta, 1:n_beta]
attr(fit_jointP$list_X[[1]], "assign")
attr(fit_jointP$list_X[[1]], "assign")
fit_jointP
attr(fit_jointP$list_X[[1]], "assign")
