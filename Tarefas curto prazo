
-------------------------------------------

Tarefas dissertação

 - Funções implementadas:
   1. ANOVA  tipo I   (imita uma sequencial)
   2. ANOVA  tipo II  (nao bate com o car)
   3. ANOVA  tipo III
   4. ANOVA  tipo III para dispersão
   5. MANOVA tipo I   (imita uma sequencial)
   6. MANOVA tipo II  (nao bate com o car)
   7. MANOVA tipo III
   8. MANOVA tipo III para dispersão
   9. Hipóteses lineares gerais especificadas pelo usuário (poder está 100% do usuário)

 - Testes com exemplos gaussianos:
	* Para modelos gaussianos univariados, a função de hipoteses lineares e ANOVA tipo III funcionam perfeitamente
	* Para dados não gaussianos as estimativas batem, mas os erros nao, por isso os testes nao sao equivalentes
	* Com a função de hipóteses lineares da pra replicar anovas, manovas, testar qualquer parametro, igualdade entre parametros, grupos de 		  parametos etc
	* As do tipo I e II nao batem, mas os testes são coerentes, isto é, eu faço testes corretos mas que não são feitos precisamente pelo car
	* Nao consegui descobrir oq o car faz na anova tipo II, achei que tinha entendido e foi a forma como implementei. Mas nao bate e nao descobri 		  precisamente oq o car testa no tipo II

 - Preparar materiais didáticos (scripts e rmds):
   1. Exemplo simples de uso das funções com um dataset qualquer (algum do mcglm por exemplo)
   2. Análise completa recorte experimento Priscilla (igual o TCC)
   3. Análise completa recorte trabalho Bruno (contagens subdispersas)
   4. Algum outro problema (Bruna nutrição?)

 - Planejar o estudo de simulação

-------------------------------------------

Tarefas trabalho Bruno

 - Base 1: modelo está bem ajustado. 

 - Refazer exploratória com a base toda (no modelo final
   foi usada a base toda)

 - Fazer um relatório rmd com os resultados

 - Transformar todas as variáveis em binárias e avaliar se há perda

 - ANÁLISE 
   opção 1: ser mais restritivo com os mal ajustados e ajustar outro 
   modelo so para eles com foco em count alto (comuns)

   opção 2: aumentar a base para dar mais enfase nos individuos com
   count alto que aparecem pouco (nao parece uma boa ideia)

  opção 3: manter individuos mal ajustados com count alto e verificar
  oq acontece

 - PENSAR NO PAPER PARA ESTATISTICA

-------------------------------------------

mc_linear_hypothesis <- function(object, hypothesis){
  
  # Vetor beta chapeu
  coefs <- coef(object, type = c("beta", "tau", "power"))
  
  #----------------------------------------------------------------
  
  # Número de parametros
  n_coefs <- sum(as.vector(table(coefs$Response)))
  
  #----------------------------------------------------------------
  
  # Número de respostas
  n_resp <- length(as.vector(table(coefs$Response)))
  
  #----------------------------------------------------------------
  
  # vcov
  vcov_coefs <- vcov(object)[as.vector(coefs$Parameters),
                             as.vector(coefs$Parameters)]

  #----------------------------------------------------------------
  
  # Quebrando as strings recebidas como argumento (hipóteses)
  hypothesis2 <- stringr::str_split(hypothesis, 
                                    pattern = c('='), 
                                    simplify = T)
  
  #----------------------------------------------------------------
  
  # Gerando um data frame
  hypothesis3 <- as.data.frame(hypothesis2)
  names(hypothesis3) <- c('parameters', 'null_hyp')
  
  #----------------------------------------------------------------
  
  # Retirando espaços
  hypothesis3$parameters <- stringr::str_replace(hypothesis3$parameters, " ",  "")
  hypothesis3$null_hyp <- stringr::str_replace(hypothesis3$null_hyp, " ",  "")
  
  #----------------------------------------------------------------
  
  # Gerando a matriz L
  L_user <- matrix(nrow = nrow(hypothesis3), ncol = n_coefs)
  
  colnames(L_user) <- as.vector(coefs$Parameters)
  
  for (i in 1:nrow(L_user)) {
    L_user[i,] <- ifelse(colnames(L_user) == hypothesis3$parameters[i],
                         1,0)  
  }
  
  for (i in 1:nrow(L_user)) {
    L_user[i,] <- ifelse(colnames(L_user) == hypothesis3$null_hyp[i],
                         -1,L_user[i,])  
  }
  
  #----------------------------------------------------------------
  
  # Substitui strings por 0 (hipóteses de igualdade)
  hypothesis3$null_hyp <- ifelse(stringr::str_detect(hypothesis3$null_hyp, c('beta')) == T,0,hypothesis3$null_hyp)
  hypothesis3$null_hyp <- ifelse(stringr::str_detect(hypothesis3$null_hyp, c('tau')) == T,0,hypothesis3$null_hyp)
  hypothesis3$null_hyp <- ifelse(stringr::str_detect(hypothesis3$null_hyp, c('power')) == T,0,hypothesis3$null_hyp)
  
  #----------------------------------------------------------------
  
  # Converte valores da hipótese nula para numericas
  hypothesis3$null_hyp <- as.numeric(hypothesis3$null_hyp)
  
  #----------------------------------------------------------------
  
  # Efetua o teste
  
  W <- vector() # Vetor para a estatística de teste
  gl <- vector() # Vetor para graus de liberdade
  p_val <- vector() # Vetor para p-valor
  
  W <- as.numeric((t((L_user%*%coefs$Estimates) - hypothesis3$null_hyp)) %*% (solve(L_user%*%vcov_coefs%*%t(L_user))) %*% ((L_user%*%coefs$Estimates) - hypothesis3$null_hyp))
  gl <- nrow(L_user)
  p_val <- pchisq(W, df = gl, lower.tail = FALSE)
  
  tabela <- data.frame(GL = gl,
                       W = round(W, 4),
                       P_valor = round(p_val, 4))
  
  return(tabela)
  
}

