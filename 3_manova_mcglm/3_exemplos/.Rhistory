library(Matrix)
source('~/msc/3_manova_mcglm/2_funcoes/functions2.R')
dados <- read.csv2("NBA.csv",
header = T,
sep = ";",
dec = ',')
dados$X6 <- sample(as.factor(rep(c('nivel_1', 'nivel_2',
'nivel_3', 'nivel_4',
'nivel_5', 'nivel_6'), 9)))
names(dados) <- c('x1', 'x2', 'y1', 'y2', 'y3', 'x3')
summary(dados)
disp <- function(form, data){
plot(form, data)
abline(lm(form, data), col = 2, lwd = 2)
}
par(mfrow = c(2,3))
disp(y1~x1, dados)
disp(y1~x2, dados)
plot(y1~x3, dados)
disp(y2~x1, dados)
disp(y2~x2, dados)
plot(y2~x3, dados)
cor1 <- cor(dados[,-ncol(dados)])
par(mfrow = c(1,1))
corrplot::corrplot.mixed(cor1,
lower = 'number',
upper = 'ellipse')
form1 <- y1 ~ x1+x2+x3
form2 <- y2 ~ x1+x2+x3
form3 <- y3 ~ x1+x2+x3
Z0 <- mc_id(dados) # Identidade
fit <-
mcglm(linear_pred = c(form1,
form2,
form3),
matrix_pred = list(c(Z0),
c(Z0),
c(Z0)),
link = c("identity","identity","identity"),
variance = c("tweedie",
"tweedie",
"tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
data = dados)
mc_anova_disp(fit)
mc_manova_disp(fit)
mc_anova_power(fit)
fit <-
mcglm(linear_pred = c(form1,
form2,
form3),
matrix_pred = list(c(Z0),
c(Z0),
c(Z0)),
link = c("identity","identity","identity"),
variance = c("tweedie",
"tweedie",
"tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F,F),
data = dados)
c(F,F)
fit <-
mcglm(linear_pred = c(form1,
form2,
form3),
matrix_pred = list(c(Z0),
c(Z0),
c(Z0)),
link = c("identity","identity","identity"),
variance = c("tweedie",
"tweedie",
"tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
data = dados)
mc_anova_disp(fit)
mc_manova_disp(fit)
mc_anova_disp(fit)
i = 1
mc_anova_pc[[i]]
mc_anova_pc <- anova(fit)
i = 1
mc_anova_pc[[i]]
mc_anova_I(fit)[[i]]
mc_anova_II(fit)[[i]]
mc_anova_III(fit)[[i]]
mc_manova(fit)
library(mcglm)
library(Matrix)
source('~/msc/3_manova_mcglm/2_funcoes/functions2.R')
library(mcglm)
library(Matrix)
source('~/msc/3_manova_mcglm/2_funcoes/functions2.R')
dados <- read.csv2("NBA.csv",
header = T,
sep = ";",
dec = ',')
dados$X6 <- sample(as.factor(rep(c('nivel_1', 'nivel_2',
'nivel_3', 'nivel_4',
'nivel_5', 'nivel_6'), 9)))
names(dados) <- c('x1', 'x2', 'y1', 'y2', 'y3', 'x3')
summary(dados)
disp <- function(form, data){
plot(form, data)
abline(lm(form, data), col = 2, lwd = 2)
}
par(mfrow = c(2,3))
disp(y1~x1, dados)
disp(y1~x2, dados)
plot(y1~x3, dados)
disp(y2~x1, dados)
disp(y2~x2, dados)
plot(y2~x3, dados)
cor1 <- cor(dados[,-ncol(dados)])
par(mfrow = c(3,3))
disp(y1~x1, dados)
disp(y1~x2, dados)
x11()
par(mfrow = c(3,3))
disp(y1~x1, dados)
disp(y1~x2, dados)
plot(y1~x3, dados)
disp(y2~x1, dados)
disp(y2~x2, dados)
plot(y2~x3, dados)
disp(y3~x1, dados)
disp(y3~x2, dados)
plot(y3~x3, dados)
cor1 <- cor(dados[,-ncol(dados)])
cor1 <- cor(dados[,-ncol(dados)])
par(mfrow = c(1,1))
corrplot::corrplot.mixed(cor1,
lower = 'number',
upper = 'ellipse')
form1 <- y1 ~ x1+x2+x3
form2 <- y2 ~ x1+x2+x3
form3 <- y3 ~ x1+x2+x3
Z0 <- mc_id(dados) # Identidade
fit <-
mcglm(linear_pred = c(form1,
form2,
form3),
matrix_pred = list(c(Z0),
c(Z0),
c(Z0)),
link = c("identity","identity","identity"),
variance = c("tweedie",
"tweedie",
"tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
data = dados)
fit$beta_names[[1]]
mc_anova_pc <- anova(fit)
i = 1
mc_anova_pc[[i]]
mc_anova_III(fit)[[i]]
mc_anova_II(fit)[[i]]
mc_anova_II(fit)[[i]] == mc_anova_III(fit)[[i]]
mc_anova_I(fit)[[i]]
mc_anova_disp(fit)
mc_anova_power(fit)
mc_manova(fit)
mc_manova_III(fit)
mc_manova_II(fit)
mc_manova_I(fit)
mc_manova_power(fit)
mc_manova_disp(fit)
mc_manova_power(fit)
form1 <- y1 ~ (x1+x2+x3)^2
form2 <- y2 ~ (x1+x2+x3)^2
form3 <- y3 ~ (x1+x2+x3)^2
Z0 <- mc_id(dados) # Identidade
fit <-
mcglm(linear_pred = c(form1,
form2,
form3),
matrix_pred = list(c(Z0),
c(Z0),
c(Z0)),
link = c("identity","identity","identity"),
variance = c("tweedie",
"tweedie",
"tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
data = dados)
mc_anova_pc <- anova(fit)
i = 1
mc_anova_pc[[i]]
mc_anova_III(fit)[[i]]
mc_anova_II(fit)[[i]]
mc_anova_I(fit)[[i]]
mc_anova_disp(fit)
mc_anova_power(fit)
mc_manova(fit)
mc_manova_III(fit)
mc_manova_II(fit)
mc_manova_I(fit)
mc_manova_disp(fit)
mc_manova_power(fit)
library(mcglm)
library(Matrix)
source('~/msc/3_manova_mcglm/2_funcoes/functions2.R')
#---------------------------------------------------------------
dados <- read.csv2("dados_ovelhas.csv",
header = T,
sep = ";",
dec = ',')
dados2 <- dados[,c(1,2,3,4,
14,15,17,21,
7,9,10,11)]
dados2$momento <- ordered(dados2$tempo,
levels=c("Antes", "Durante", "Depois"))
form.ncorpo  <- ncorpo  ~ (sessao + tempo + linhagem)
form.ncorpo2 <- ncabeca ~ (sessao + tempo + linhagem)
form.ncorpo3 <- norelha ~ (sessao + tempo + linhagem)
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
fit_jointP$beta_names[[1]]
summary(fit_jointP)
mc_anova_pc <- anova(fit_jointP)
i = 1
mc_anova_pc[[i]]
mc_anova_III(fit_jointP)[[i]]
mc_anova_II(fit_jointP)[[i]]
mc_anova_I(fit_jointP)[[i]]
mc_anova_disp(fit_jointP)
mc_anova_power(fit_jointP)
mc_anova_power(fit_jointP)
mc_manova_power(fit_jointP)
mc_manova(fit_jointP)
mc_manova_III(fit_jointP)
mc_manova_II(fit_jointP)
mc_manova_I(fit_jointP)
mc_manova_disp(fit_jointP)
form.ncorpo  <- ncorpo  ~ (sessao + tempo + linhagem)^2
form.ncorpo2 <- ncabeca ~ (sessao + tempo + linhagem)^2
form.ncorpo3 <- norelha ~ (sessao + tempo + linhagem)^2
Z0 <- mc_id(dados2) # Identidade
Z1 <- mc_mixed(~0 + factor(animal), data = dados2) # Animal
dados2$comb <- paste(dados2$animal, dados2$sessao)
Z2 <- mc_mixed(~0 + comb, data = dados2) # Animal Momento
fit_jointP <-
mcglm(linear_pred = c(form.ncorpo,
form.ncorpo2,
form.ncorpo3),
matrix_pred = list(c(Z0, Z1, Z2),
c(Z0, Z1, Z2),
c(Z0, Z1, Z2)),
link = c("log","log","log"),
variance = c("poisson_tweedie",
"poisson_tweedie",
"poisson_tweedie"),
control_algorithm = list(verbose = T,
tuning = 0.1,
max_iter = 20,
tol = 1e-01),
power_fixed = c(F, F, F),
data = dados2)
fit_jointP$beta_names[[1]]
summary(fit_jointP)
mc_anova_pc <- anova(fit_jointP)
i = 1
mc_anova_pc[[i]]
mc_anova_III(fit_jointP)[[i]]
mc_anova_II(fit_jointP)[[i]]
mc_anova_I(fit_jointP)[[i]]
mc_anova_disp(fit_jointP)
mc_anova_power(fit_jointP)
mc_manova(fit_jointP)
mc_manova_III(fit_jointP)
mc_manova_II(fit_jointP)
mc_manova_I(fit_jointP)
mc_manova_disp(fit_jointP)
mc_manova_power(fit_jointP)
object
#' of the significance for the power components by response
#' variables for model objects produced by mcglm.
#'
#' @param object an object of \code{mcglm} class.
#' @param ... additional arguments affecting the summary produced. Note
#'     that there is no extra options for mcglm object class.
#' @keywords internal
#' @return ANOVA table for power components of mcglm objects.
#'
#' @export
object <- fit_jointP
# Vetor power e indice de resposta
power <- coef(object, type = "power")[,c(1,2,4)]
power
# Número de powers por resposta
n_power <- as.vector(table(power$Response))
# Número de respostas
n_resp <- length(n_power)
vcov_power <- list()
padrao <- vector()
for (j in 1:n_resp) {
for (i in 1:length(row.names(vcov(object)))) {
padrao[i] <- sjmisc::str_contains(rownames(vcov(object))[i],
pattern = paste0('power',j))
}
names <- data.frame(row_names = row.names(vcov(object)),
id = padrao)
names2 <- as.vector(subset(names, id == TRUE)$row_names)
vcov_power[[j]] <- vcov(object)[names2, names2]
}
p_var <- list()
for (i in 1:n_resp) {
p_var[[i]] <- 0:(n_power[i]-1)
}
# Matriz L para todos os parâmetros (Hypothesis matrix), por resposta
L_all <- list()
for (i in 1:n_resp) {
L_all[[i]] <- diag(length(p_var[[i]]))
}
L_par <- list()
for (i in 1:n_resp) {
L_par[[i]] <- by(data = L_all[[i]],
INDICES = p_var[[i]],
FUN = as.matrix)
}
tabela <- list()
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = power_names[j],
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
tabela <- list()
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = paste0('power',1:(n_tau[i])),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
tabela <- list()
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = paste0('power',1:(n_power[i])),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
tabela
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = paste0('power',1:(n_power[j])),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
tabela
return(tabela)
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = paste0('power',1:(n_power[i])),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
return(tabela)
mc_anova_power <- function(object){
# Vetor power e indice de resposta
power <- coef(object, type = "power")[,c(1,2,4)]
#----------------------------------------------------------------
# Número de powers por resposta
n_power <- as.vector(table(power$Response))
#----------------------------------------------------------------
# Número de respostas
n_resp <- length(n_power)
#----------------------------------------------------------------
# Lista vcov por resposta desconsiderando parametros de
# regressao e dispersao
vcov_power <- list()
padrao <- vector()
for (j in 1:n_resp) {
for (i in 1:length(row.names(vcov(object)))) {
padrao[i] <- sjmisc::str_contains(rownames(vcov(object))[i],
pattern = paste0('power',j))
}
names <- data.frame(row_names = row.names(vcov(object)),
id = padrao)
names2 <- as.vector(subset(names, id == TRUE)$row_names)
vcov_power[[j]] <- vcov(object)[names2, names2]
}
#----------------------------------------------------------------
# Índice que associa tau a matriz Z
p_var <- list()
for (i in 1:n_resp) {
p_var[[i]] <- 0:(n_power[i]-1)
}
#----------------------------------------------------------------
# Matriz L para todos os parâmetros (Hypothesis matrix), por resposta
L_all <- list()
for (i in 1:n_resp) {
L_all[[i]] <- diag(length(p_var[[i]]))
}
#----------------------------------------------------------------
# Matriz L por variável (Hypothesis matrix), por resposta
L_par <- list()
for (i in 1:n_resp) {
L_par[[i]] <- by(data = L_all[[i]],
INDICES = p_var[[i]],
FUN = as.matrix)
}
#----------------------------------------------------------------
## Tabela
tabela <- list()
for (j in 1:n_resp) {
W <- vector() # Vetor para a estatística de teste
gl <- vector() # Vetor para graus de liberdade
p_val <- vector() # Vetor para p-valor
for (i in 1:dim(L_par[[j]])) {
W[i] <- as.numeric((t(L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates)) %*% (solve(L_par[[j]][[i]]%*%vcov_power[[j]]%*%t(L_par[[j]][[i]]))) %*% (L_par[[j]][[i]] %*% subset(power, power$Response == j)$Estimates))
gl[i] <- ifelse(is.null(nrow(L_par[[j]][[i]])) == TRUE,
1,nrow(L_par[[j]][[i]]))
p_val[i] <- pchisq(W[i], df = gl[i], lower.tail = FALSE)
}
tabela[[j]] <-
data.frame(Variável = paste0('power',1:(n_power[i])),
GL = gl,
W = round(W, 3),
P_valor = round(p_val, 3))
}
return(tabela)
}
mc_manova_power(fit)
mc_anova_power(fit)
mc_anova_disp(fit_jointP)
mc_anova_power(fit_jointP)
mc_manova_power(fit_jointP)
mc_manova_disp(fit_jointP)
